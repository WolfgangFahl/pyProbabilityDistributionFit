{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyProbabilityDistributionFit API Documentation","text":""},{"location":"#pdffit.distfit","title":"<code>distfit</code>","text":"<p>Created on 2022-05-17</p> <p>see    https://stackoverflow.com/questions/6620471/fitting-empirical-distribution-to-theoretical-ones-with-scipy-python/37616966#37616966</p> <p>@author: https://stackoverflow.com/users/832621/saullo-g-p-castro see https://stackoverflow.com/a/37616966/1497139</p> <p>@author: https://stackoverflow.com/users/2087463/tmthydvnprt see  https://stackoverflow.com/a/37616966/1497139</p> <p>@author: https://stackoverflow.com/users/1497139/wolfgang-fahl see</p>"},{"location":"#pdffit.distfit.BestFitDistribution","title":"<code>BestFitDistribution</code>","text":"<p>Find the best Probability Distribution Function for the given data</p> Source code in <code>pdffit/distfit.py</code> <pre><code>class BestFitDistribution:\n    \"\"\"\n    Find the best Probability Distribution Function for the given data\n    \"\"\"\n\n    def __init__(\n        self,\n        data,\n        backend: str = \"WebAgg\",\n        distributionNames: list = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            data(dataFrame): the data to analyze\n            distributionNames(list): list of distributionNames to try\n            debug(bool): if True show debugging information\n        \"\"\"\n        self.debug = debug\n        self.backend = backend\n        self.matplotLibParams()\n        if distributionNames is None:\n            self.distributionNames = [\n                d for d in _distn_names if not d in [\"levy_stable\", \"studentized_range\"]\n            ]\n        else:\n            self.distributionNames = distributionNames\n        self.data = data\n\n    def matplotLibParams(self):\n        \"\"\"\n        set matplotlib parameters\n        \"\"\"\n        matplotlib.rcParams[\"figure.figsize\"] = (16.0, 12.0)\n        matplotlib.style.use(\"ggplot\")\n        matplotlib.use(self.backend)\n\n    # Create models from data\n    def best_fit_distribution(self, bins: int = 200, ax=None, density: bool = True):\n        \"\"\"\n        Model data by finding best fit distribution to data\n        \"\"\"\n        # Get histogram of original data\n        y, x = np.histogram(self.data, bins=bins, density=density)\n        x = (x + np.roll(x, -1))[:-1] / 2.0\n\n        # Best holders\n        best_distributions = []\n        distributionCount = len(self.distributionNames)\n        # Estimate distribution parameters from data\n        for ii, distributionName in enumerate(self.distributionNames):\n\n            print(f\"{ii+1:&gt;3} / {distributionCount:&lt;3}: {distributionName}\")\n\n            distribution = getattr(st, distributionName)\n\n            # Try to fit the distribution\n            try:\n                # Ignore warnings from data that can't be fit\n                with warnings.catch_warnings():\n                    warnings.filterwarnings(\"ignore\")\n\n                    # fit dist to data\n                    params = distribution.fit(self.data)\n\n                    # Separate parts of parameters\n                    arg = params[:-2]\n                    loc = params[-2]\n                    scale = params[-1]\n\n                    # Calculate fitted PDF and error with fit in distribution\n                    pdf = distribution.pdf(x, loc=loc, scale=scale, *arg)\n                    sse = np.sum(np.power(y - pdf, 2.0))\n\n                    # if axis pass in add to plot\n                    try:\n                        if ax:\n                            pd.Series(pdf, x).plot(ax=ax)\n                    except Exception:\n                        pass\n\n                    # identify if this distribution is better\n                    best_distributions.append((distribution, params, sse))\n\n            except Exception as ex:\n                if self.debug:\n                    trace = traceback.format_exc()\n                    msg = f\"fit for {distributionName} failed:{ex}\\n{trace}\"\n                    print(msg, file=sys.stderr)\n                pass\n\n        return sorted(best_distributions, key=lambda x: x[2])\n\n    def make_pdf(self, dist, params: list, size=10000):\n        \"\"\"\n        Generate distributions's Probability Distribution Function\n\n        Args:\n            dist: Distribution\n            params(list): parameter\n            size(int): size\n\n        Returns:\n            dataframe: Power Distribution Function\n\n        \"\"\"\n\n        # Separate parts of parameters\n        arg = params[:-2]\n        loc = params[-2]\n        scale = params[-1]\n\n        # Get sane start and end points of distribution\n        start = (\n            dist.ppf(0.01, *arg, loc=loc, scale=scale)\n            if arg\n            else dist.ppf(0.01, loc=loc, scale=scale)\n        )\n        end = (\n            dist.ppf(0.99, *arg, loc=loc, scale=scale)\n            if arg\n            else dist.ppf(0.99, loc=loc, scale=scale)\n        )\n\n        # Build PDF and turn into pandas Series\n        x = np.linspace(start, end, size)\n        y = dist.pdf(x, loc=loc, scale=scale, *arg)\n        pdf = pd.Series(y, x)\n\n        return pdf\n\n    def analyze(\n        self,\n        title,\n        x_label,\n        y_label,\n        facecolor=\"b\",\n        alpha=0.5,\n        callback: Callable = None,\n        outputFilePrefix=None,\n        imageFormat: str = \"png\",\n        allBins: int = 50,\n        distBins: int = 200,\n        density: bool = True,\n    ):\n        \"\"\"\n\n        analyze the Probabilty Distribution Function\n\n        Args:\n            data: Panda Dataframe or numpy array\n            title(str): the title to use\n            x_label(str): the label for the x-axis\n            y_label(str): the label for the y-axis\n\n            facecolor(str): the color to use\n            alpha(float): the opacity to use\n\n            callback(Callable): a function to be called for the plots\n\n            outputFilePrefix(str): the prefix of the outputFile\n            imageFormat(str): imageFormat e.g. png,svg\n\n            allBins(int): the number of bins for all\n            distBins(int): the number of bins for the distribution\n            density(bool): if True show relative density\n        \"\"\"\n        self.allBins = allBins\n        self.distBins = distBins\n        self.density = density\n        self.title = title\n        self.x_label = x_label\n        self.y_label = y_label\n        self.facecolor = facecolor\n        self.alpha = alpha\n        self.callback = callback\n        self.imageFormat = imageFormat\n        self.outputFilePrefix = outputFilePrefix\n        self.best_dist = None\n        self.analyzeAll()\n        if self.callback:\n            self.callback(self.figAll, isAll=True)\n        if outputFilePrefix is not None:\n            self.saveFig(f\"{outputFilePrefix}All.{imageFormat}\", imageFormat)\n            plt.close(self.figAll)\n        if self.best_dist:\n            self.analyzeBest()\n            if self.callback:\n                self.callback(self.figBest, isAll=False)\n            if outputFilePrefix is not None:\n                self.saveFig(f\"{outputFilePrefix}Best.{imageFormat}\", imageFormat)\n                plt.close(self.figBest)\n\n    def analyzeAll(self):\n        \"\"\"\n        analyze the given data\n\n        \"\"\"\n        # Plot for comparison\n        figTitle = f\"{self.title}\\n All Fitted Distributions\"\n        self.figAll = plt.figure(figTitle, figsize=(12, 8))\n        ax = self.data.plot(\n            kind=\"hist\",\n            bins=self.allBins,\n            density=self.density,\n            alpha=self.alpha,\n            facecolor=self.facecolor,\n        )\n\n        # Save plot limits\n        dataYLim = ax.get_ylim()\n        # Update plots\n        ax.set_ylim(dataYLim)\n        ax.set_title(figTitle)\n        ax.set_xlabel(self.x_label)\n        ax.set_ylabel(self.y_label)\n\n        # Find best fit distribution\n        best_distributions = self.best_fit_distribution(\n            bins=self.distBins, ax=ax, density=self.density\n        )\n        if len(best_distributions) &gt; 0:\n            self.best_dist = best_distributions[0]\n            # Make PDF with best params\n            self.pdf = self.make_pdf(self.best_dist[0], self.best_dist[1])\n\n    def analyzeBest(self):\n        \"\"\"\n        analyze the Best Property Distribution function\n        \"\"\"\n        # Display\n        figLabel = \"PDF\"\n        self.figBest = plt.figure(figLabel, figsize=(12, 8))\n        ax = self.pdf.plot(lw=2, label=figLabel, legend=True)\n        self.data.plot(\n            kind=\"hist\",\n            bins=self.allBins,\n            density=self.density,\n            alpha=self.alpha,\n            label=\"Data\",\n            legend=True,\n            ax=ax,\n            facecolor=self.facecolor,\n        )\n\n        param_names = (\n            (self.best_dist[0].shapes + \", loc, scale\").split(\", \")\n            if self.best_dist[0].shapes\n            else [\"loc\", \"scale\"]\n        )\n        param_str = \", \".join(\n            [\"{}={:0.2f}\".format(k, v) for k, v in zip(param_names, self.best_dist[1])]\n        )\n        dist_str = \"{}({})\".format(self.best_dist[0].name, param_str)\n\n        ax.set_title(f\"{self.title} with best fit distribution \\n\" + dist_str)\n        ax.set_xlabel(self.x_label)\n        ax.set_ylabel(self.y_label)\n\n    def saveFig(self, outputFile: str = None, imageFormat=\"png\"):\n        \"\"\"\n        save the current Figure to the given outputFile\n\n        Args:\n            outputFile(str): the outputFile to save to\n            imageFormat(str): the imageFormat to use e.g. png/svg\n        \"\"\"\n        plt.savefig(outputFile, format=imageFormat)  # dpi\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.__init__","title":"<code>__init__(data, backend='WebAgg', distributionNames=None, debug=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>data(dataFrame)</code> <p>the data to analyze</p> required <code>distributionNames(list)</code> <p>list of distributionNames to try</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required Source code in <code>pdffit/distfit.py</code> <pre><code>def __init__(\n    self,\n    data,\n    backend: str = \"WebAgg\",\n    distributionNames: list = None,\n    debug: bool = False,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        data(dataFrame): the data to analyze\n        distributionNames(list): list of distributionNames to try\n        debug(bool): if True show debugging information\n    \"\"\"\n    self.debug = debug\n    self.backend = backend\n    self.matplotLibParams()\n    if distributionNames is None:\n        self.distributionNames = [\n            d for d in _distn_names if not d in [\"levy_stable\", \"studentized_range\"]\n        ]\n    else:\n        self.distributionNames = distributionNames\n    self.data = data\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.analyze","title":"<code>analyze(title, x_label, y_label, facecolor='b', alpha=0.5, callback=None, outputFilePrefix=None, imageFormat='png', allBins=50, distBins=200, density=True)</code>","text":"<p>analyze the Probabilty Distribution Function</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Panda Dataframe or numpy array</p> required <code>title(str)</code> <p>the title to use</p> required <code>x_label(str)</code> <p>the label for the x-axis</p> required <code>y_label(str)</code> <p>the label for the y-axis</p> required <code>facecolor(str)</code> <p>the color to use</p> required <code>alpha(float)</code> <p>the opacity to use</p> required <code>callback(Callable)</code> <p>a function to be called for the plots</p> required <code>outputFilePrefix(str)</code> <p>the prefix of the outputFile</p> required <code>imageFormat(str)</code> <p>imageFormat e.g. png,svg</p> required <code>allBins(int)</code> <p>the number of bins for all</p> required <code>distBins(int)</code> <p>the number of bins for the distribution</p> required <code>density(bool)</code> <p>if True show relative density</p> required Source code in <code>pdffit/distfit.py</code> <pre><code>def analyze(\n    self,\n    title,\n    x_label,\n    y_label,\n    facecolor=\"b\",\n    alpha=0.5,\n    callback: Callable = None,\n    outputFilePrefix=None,\n    imageFormat: str = \"png\",\n    allBins: int = 50,\n    distBins: int = 200,\n    density: bool = True,\n):\n    \"\"\"\n\n    analyze the Probabilty Distribution Function\n\n    Args:\n        data: Panda Dataframe or numpy array\n        title(str): the title to use\n        x_label(str): the label for the x-axis\n        y_label(str): the label for the y-axis\n\n        facecolor(str): the color to use\n        alpha(float): the opacity to use\n\n        callback(Callable): a function to be called for the plots\n\n        outputFilePrefix(str): the prefix of the outputFile\n        imageFormat(str): imageFormat e.g. png,svg\n\n        allBins(int): the number of bins for all\n        distBins(int): the number of bins for the distribution\n        density(bool): if True show relative density\n    \"\"\"\n    self.allBins = allBins\n    self.distBins = distBins\n    self.density = density\n    self.title = title\n    self.x_label = x_label\n    self.y_label = y_label\n    self.facecolor = facecolor\n    self.alpha = alpha\n    self.callback = callback\n    self.imageFormat = imageFormat\n    self.outputFilePrefix = outputFilePrefix\n    self.best_dist = None\n    self.analyzeAll()\n    if self.callback:\n        self.callback(self.figAll, isAll=True)\n    if outputFilePrefix is not None:\n        self.saveFig(f\"{outputFilePrefix}All.{imageFormat}\", imageFormat)\n        plt.close(self.figAll)\n    if self.best_dist:\n        self.analyzeBest()\n        if self.callback:\n            self.callback(self.figBest, isAll=False)\n        if outputFilePrefix is not None:\n            self.saveFig(f\"{outputFilePrefix}Best.{imageFormat}\", imageFormat)\n            plt.close(self.figBest)\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.analyzeAll","title":"<code>analyzeAll()</code>","text":"<p>analyze the given data</p> Source code in <code>pdffit/distfit.py</code> <pre><code>def analyzeAll(self):\n    \"\"\"\n    analyze the given data\n\n    \"\"\"\n    # Plot for comparison\n    figTitle = f\"{self.title}\\n All Fitted Distributions\"\n    self.figAll = plt.figure(figTitle, figsize=(12, 8))\n    ax = self.data.plot(\n        kind=\"hist\",\n        bins=self.allBins,\n        density=self.density,\n        alpha=self.alpha,\n        facecolor=self.facecolor,\n    )\n\n    # Save plot limits\n    dataYLim = ax.get_ylim()\n    # Update plots\n    ax.set_ylim(dataYLim)\n    ax.set_title(figTitle)\n    ax.set_xlabel(self.x_label)\n    ax.set_ylabel(self.y_label)\n\n    # Find best fit distribution\n    best_distributions = self.best_fit_distribution(\n        bins=self.distBins, ax=ax, density=self.density\n    )\n    if len(best_distributions) &gt; 0:\n        self.best_dist = best_distributions[0]\n        # Make PDF with best params\n        self.pdf = self.make_pdf(self.best_dist[0], self.best_dist[1])\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.analyzeBest","title":"<code>analyzeBest()</code>","text":"<p>analyze the Best Property Distribution function</p> Source code in <code>pdffit/distfit.py</code> <pre><code>def analyzeBest(self):\n    \"\"\"\n    analyze the Best Property Distribution function\n    \"\"\"\n    # Display\n    figLabel = \"PDF\"\n    self.figBest = plt.figure(figLabel, figsize=(12, 8))\n    ax = self.pdf.plot(lw=2, label=figLabel, legend=True)\n    self.data.plot(\n        kind=\"hist\",\n        bins=self.allBins,\n        density=self.density,\n        alpha=self.alpha,\n        label=\"Data\",\n        legend=True,\n        ax=ax,\n        facecolor=self.facecolor,\n    )\n\n    param_names = (\n        (self.best_dist[0].shapes + \", loc, scale\").split(\", \")\n        if self.best_dist[0].shapes\n        else [\"loc\", \"scale\"]\n    )\n    param_str = \", \".join(\n        [\"{}={:0.2f}\".format(k, v) for k, v in zip(param_names, self.best_dist[1])]\n    )\n    dist_str = \"{}({})\".format(self.best_dist[0].name, param_str)\n\n    ax.set_title(f\"{self.title} with best fit distribution \\n\" + dist_str)\n    ax.set_xlabel(self.x_label)\n    ax.set_ylabel(self.y_label)\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.best_fit_distribution","title":"<code>best_fit_distribution(bins=200, ax=None, density=True)</code>","text":"<p>Model data by finding best fit distribution to data</p> Source code in <code>pdffit/distfit.py</code> <pre><code>def best_fit_distribution(self, bins: int = 200, ax=None, density: bool = True):\n    \"\"\"\n    Model data by finding best fit distribution to data\n    \"\"\"\n    # Get histogram of original data\n    y, x = np.histogram(self.data, bins=bins, density=density)\n    x = (x + np.roll(x, -1))[:-1] / 2.0\n\n    # Best holders\n    best_distributions = []\n    distributionCount = len(self.distributionNames)\n    # Estimate distribution parameters from data\n    for ii, distributionName in enumerate(self.distributionNames):\n\n        print(f\"{ii+1:&gt;3} / {distributionCount:&lt;3}: {distributionName}\")\n\n        distribution = getattr(st, distributionName)\n\n        # Try to fit the distribution\n        try:\n            # Ignore warnings from data that can't be fit\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"ignore\")\n\n                # fit dist to data\n                params = distribution.fit(self.data)\n\n                # Separate parts of parameters\n                arg = params[:-2]\n                loc = params[-2]\n                scale = params[-1]\n\n                # Calculate fitted PDF and error with fit in distribution\n                pdf = distribution.pdf(x, loc=loc, scale=scale, *arg)\n                sse = np.sum(np.power(y - pdf, 2.0))\n\n                # if axis pass in add to plot\n                try:\n                    if ax:\n                        pd.Series(pdf, x).plot(ax=ax)\n                except Exception:\n                    pass\n\n                # identify if this distribution is better\n                best_distributions.append((distribution, params, sse))\n\n        except Exception as ex:\n            if self.debug:\n                trace = traceback.format_exc()\n                msg = f\"fit for {distributionName} failed:{ex}\\n{trace}\"\n                print(msg, file=sys.stderr)\n            pass\n\n    return sorted(best_distributions, key=lambda x: x[2])\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.make_pdf","title":"<code>make_pdf(dist, params, size=10000)</code>","text":"<p>Generate distributions's Probability Distribution Function</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <p>Distribution</p> required <code>params(list)</code> <p>parameter</p> required <code>size(int)</code> <p>size</p> required <p>Returns:</p> Name Type Description <code>dataframe</code> <p>Power Distribution Function</p> Source code in <code>pdffit/distfit.py</code> <pre><code>def make_pdf(self, dist, params: list, size=10000):\n    \"\"\"\n    Generate distributions's Probability Distribution Function\n\n    Args:\n        dist: Distribution\n        params(list): parameter\n        size(int): size\n\n    Returns:\n        dataframe: Power Distribution Function\n\n    \"\"\"\n\n    # Separate parts of parameters\n    arg = params[:-2]\n    loc = params[-2]\n    scale = params[-1]\n\n    # Get sane start and end points of distribution\n    start = (\n        dist.ppf(0.01, *arg, loc=loc, scale=scale)\n        if arg\n        else dist.ppf(0.01, loc=loc, scale=scale)\n    )\n    end = (\n        dist.ppf(0.99, *arg, loc=loc, scale=scale)\n        if arg\n        else dist.ppf(0.99, loc=loc, scale=scale)\n    )\n\n    # Build PDF and turn into pandas Series\n    x = np.linspace(start, end, size)\n    y = dist.pdf(x, loc=loc, scale=scale, *arg)\n    pdf = pd.Series(y, x)\n\n    return pdf\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.matplotLibParams","title":"<code>matplotLibParams()</code>","text":"<p>set matplotlib parameters</p> Source code in <code>pdffit/distfit.py</code> <pre><code>def matplotLibParams(self):\n    \"\"\"\n    set matplotlib parameters\n    \"\"\"\n    matplotlib.rcParams[\"figure.figsize\"] = (16.0, 12.0)\n    matplotlib.style.use(\"ggplot\")\n    matplotlib.use(self.backend)\n</code></pre>"},{"location":"#pdffit.distfit.BestFitDistribution.saveFig","title":"<code>saveFig(outputFile=None, imageFormat='png')</code>","text":"<p>save the current Figure to the given outputFile</p> <p>Parameters:</p> Name Type Description Default <code>outputFile(str)</code> <p>the outputFile to save to</p> required <code>imageFormat(str)</code> <p>the imageFormat to use e.g. png/svg</p> required Source code in <code>pdffit/distfit.py</code> <pre><code>def saveFig(self, outputFile: str = None, imageFormat=\"png\"):\n    \"\"\"\n    save the current Figure to the given outputFile\n\n    Args:\n        outputFile(str): the outputFile to save to\n        imageFormat(str): the imageFormat to use e.g. png/svg\n    \"\"\"\n    plt.savefig(outputFile, format=imageFormat)  # dpi\n</code></pre>"},{"location":"#pdffit.version","title":"<code>version</code>","text":"<p>Created on 2022-05-18</p> <p>@author: wf</p>"},{"location":"#pdffit.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyProbabilityDistributionFit</p> Source code in <code>pdffit/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pyProbabilityDistributionFit\n    \"\"\"\n\n    version = \"0.0.5\"\n    date = \"2022-05-18\"\n    updated = \"2022-07-05\"\n    name = \"pyProbabilityDistributionFit\"\n    description = \"Find the best Probability Distribution Function for the given data\"\n</code></pre>"}]}